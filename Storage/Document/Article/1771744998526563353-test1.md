# CSP202509D. 造题计划（上）题解

参考了知乎

https://www.zhihu.com/people/wo-shi-ren-jian-chou-chang-ke-62-9



> 这题很明显是要求出不在路径上的点的最小值。
>
> 因为树剖会把路径分成 O(log n) 段（dfs序上），因此不在路径上的点也在dfs序上是O(log n)段。拿个st表统计一下就没了。
>
> 这个做法在线且复杂度单log。

可惜的是，我并不会证明不在路径上的点 dfn 序是 O(logn)*O*(*l**o**g**n*) 段的结论。

不过这个思路启发了我，如果我们预处理一个数组 `ans` 表示该节点除去重儿子的真子树中点权最小的，那么对于一个询问其实就是对路径上的点询问 `ans` 的最小值，树链剖分很容易做到。

需要注意一些细节，从重链的顶点通过轻边跳到另一条重链的底部时，需要手动计算一个 `ans`，这个 `ans` 是除去跳过来的这个子树的该节点真子树的最小点权。

另外对于 lca*l**c**a*，由于可能是除去两个子树，所以也要单独写一下。

以及整个询问是一条链的情况，也有一部分细节。

最后不要忘了统计根节点除去 lca*l**c**a* 的子树那一部分的点权最小值。

时间复杂度 O(nlogn)*O*(*n**l**o**g**n*)，代码复杂度 O(2147483647)*O*(2147483647)调了n久。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int n, m, a[N], lg[N];
int siz[N], son[N], fa[N], dep[N];
int top[N], dfn[N], rkn[N], tim;
int ans[N], f[25][N], g[25][N];
// ans ： 该节点除去重儿子的真子树中点权最小的 
vector <int> G[N];

void pre(int u, int f) {
	fa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;
	for (auto v : G[u]) if (v ^ f) {
		pre(v, u), siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}

void dfs(int u, int tp) {
	top[u] = tp, dfn[u] = ++ tim, rkn[tim] = u;
	if (son[u]) dfs(son[u], tp);
	for (auto v : G[u]) if (v ^ son[u] && v ^ fa[u]) dfs(v, v);
}

int askf(int l, int r) {
	if (l > r) return n;
	int s = lg[r - l + 1];
	return min(f[s][l], f[s][r - (1 << s) + 1]);
}

int askg(int l, int r) {
	if (l > r) return n;
	int s = lg[r - l + 1];
	return min(g[s][l], g[s][r - (1 << s) + 1]);	
}

int Lca(int x, int y) {
	int tx = top[x], ty = top[y];
	while (tx ^ ty) {
		if (dep[tx] < dep[ty]) swap(tx, ty), swap(x, y);
		x = fa[tx], tx = top[x];
	}
	if (dep[x] < dep[y]) swap(x, y);
	return y;
}

int findson(int x, int lca) {
	if (x == lca) return -1;
	int tx = top[x], las = x;
	while (tx ^ top[lca]) {
		las = tx, x = fa[tx], tx = top[x];
	}
	if (x == lca) return las;
	return son[lca];
}

int query(int x, int y) {
	if (x == y) return (a[x] == 0);
	int tx = top[x], ty = top[y], lca = Lca(x, y), ret = n;
	int fu = findson(x, lca), fv = findson(y, lca);
	if ((x ^ lca) && (y ^ lca)) {
		ret = min(askf(dfn[x] + 1, dfn[x] + siz[x] - 1), askf(dfn[y] + 1, dfn[y] + siz[y] - 1));
	} else {
		if (dep[x] < dep[y]) swap(x, y), swap(tx, ty);
		ret = askf(dfn[x] + 1, dfn[x] + siz[x] - 1);
	}
	ret = min({ret, askf(1, dfn[lca] - 1), askf(dfn[lca] + siz[lca], n)});
	while (tx ^ ty) {
		if (dep[tx] < dep[ty]) swap(tx, ty), swap(x, y);
		ret = min(ret, askg(dfn[tx], dfn[fa[x]]));
		if (fa[tx] ^ lca)
			ret = min({ret, askf(dfn[fa[tx]] + 1, dfn[tx] - 1), askf(dfn[tx] + siz[tx], dfn[fa[tx]] + siz[fa[tx]] - 1)});
		x = fa[tx], tx = top[x];
	}
	if (dep[x] < dep[y]) swap(x, y);
	if (son[y]) ret = min(ret, askg(dfn[son[y]], dfn[fa[x]])); // y is lca
	if (fu > fv) swap(fu, fv);
	if (fu == -1) {
		ret = min({ret, askf(dfn[lca] + 1, dfn[fv] - 1), askf(dfn[fv] + siz[fv], dfn[lca] + siz[lca] - 1)});
		return ret;
	}
	if (dfn[fu] > dfn[fv]) swap(fu, fv);
	ret = min({ret, askf(dfn[lca] + 1, dfn[fu] - 1), askf(dfn[fu] + siz[fu], dfn[fv] - 1), 
		askf(dfn[fv] + siz[fv], dfn[lca] + siz[lca] - 1)});
	return ret;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	for (int i = 1; i < n; i ++) {
		int x, y;
		scanf("%d%d", &x, &y);
		G[x].push_back(y), G[y].push_back(x);
	}
	pre(1, 1), dfs(1, 1), lg[2] = 1;
	for (int i = 3; i <= n; i ++) lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i ++) f[0][i] = a[rkn[i]];
	for (int j = 1; j <= 23; j ++)
		for (int i = 1; i + (1 << j) - 1 <= n; i ++)
			f[j][i] = min(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]);
	for (int u = 1; u <= n; u ++)
		ans[u] = son[u] ? min(askf(dfn[u] + 1, dfn[son[u]] - 1), askf(dfn[son[u]] + siz[son[u]], dfn[u] + siz[u] - 1)) : n;
	for (int i = 1; i <= n; i ++) g[0][i] = ans[rkn[i]];
	for (int j = 1; j <= 21; j ++)
		for (int i = 1; i + (1 << j) - 1 <= n; i ++)
			g[j][i] = min(g[j - 1][i], g[j - 1][i + (1 << (j - 1))]);		
	for (int i = 1; i <= m; i ++) {
		int x, y;
		scanf("%d%d", &x, &y);
		printf("%d\n", query(x, y));
	}
	return 0;
}
```

update：不在路径上的点为 log 段应该说的是：把在路径上的点树链剖分成 log 段后，直接查询每段 dfn 区间的左边一截和右边一截，这样就是 log 段了。